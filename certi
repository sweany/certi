#!/usr/bin/env python3

import argparse
from datetime import datetime
import json
import os
import sys
import ssl
import OpenSSL.crypto
import sqlite3 as lite

# https://pyopenssl.org/en/stable/api/crypto.html
#print(ssl.OPENSSL_VERSION)
CA_FILE = '/etc/ssl/certs/ca-certificates.crt'

dir_path = os.path.dirname(os.path.realpath(__file__))
dbfile = dir_path + '/certi.db'


def getcert(args):
    try:
        cert = ssl.get_server_certificate((args.target, args.port))
    except ConnectionRefusedError as e:
        print("Unable to get certificate: {}".format(e))
        sys.exit(1)
    except ssl.SSLError as e:
        print("SSL error: {}".format(e))
        print("Your openssl version ({}) may not support any common ciphers with the target.".format(ssl.OPENSSL_VERSION))
        sys.exit(1)

    #print(cert)
    #print("{}  {}:{}".format(str(datetime.now()), args.target, args.port))

    x = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
    print(x.get_subject())
    print(x.get_issuer())
    print(x.get_serial_number())
    print(x.get_signature_algorithm())
    print(x.get_notBefore())
    print(x.get_notAfter())
    for i in range(x.get_extension_count()-1):
        e = x.get_extension(i)
        n = e.get_short_name()
        print("{} {}".format(n, e.__str__()))

    try:
        s = lite.connect(dbfile, isolation_level=None)
        cur = s.cursor()
        try:
            cur.execute("CREATE TABLE IF NOT EXISTS certs(id INTEGER PRIMARY KEY AUTOINCREMENT, datestamp INT, target TEXT, port INT, cert TEXT)")
        except lite.OperationalError as e:
            #print(e)
            pass
        try:
            cur.execute("INSERT INTO certs(datestamp, target, port, cert) VALUES ({}, '{}', {}, '{}')".format(datetime.now().strftime("%s"), args.target, args.port, cert))
        except:
            print("could not insert data: {}".format(e))
    except lite.Error as e:
        print("failed to connect to {}: {}".format(dbfile, e))
        sys.exit(1)

    s.close()


def report(args):
    print("connecting to {}".format(dbfile))
    try:
        s = lite.connect(dbfile)
        cur = s.cursor()
        try:
            cur.execute("select * from certs")
        except:
            print("select failed")
    except lite.Error as e:
        print("failed to connect to {}: {}".format(dbfile, e))
        sys.exit(1)

    rows = cur.fetchall()
    for row in rows:
        print(row)



def main():
    parser = argparse.ArgumentParser(description='Catalog x509 certificates.')

    # positional argument
    parser.add_argument('mode',
                        action='store',
                        choices=['host', 'scan', 'file', 'dir', 'sniff', 'report'],
                        help='operating mode')
    # optional arguments
    parser.add_argument('-t', action='store', dest='target', default='localhost', help='host to test')
    parser.add_argument('-p', action='store', dest='port', default=443, help='port to test')
    parser.add_argument('-f', action='store', dest='db', default='certi.db', help='certificate db')

    args = parser.parse_args()

    target = args.target
    port = args.port

    modes = {'host': getcert,
             'report': report}

    try:
        modes[args.mode](args)
    except:
        #print("Invalid command line arguments.")
        raise
        sys.exit()


if __name__ == "__main__":
    main()


