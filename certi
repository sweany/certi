#!/usr/bin/env python3

import argparse
from datetime import datetime
import ipaddress
import json
import os
import re
from socket import setdefaulttimeout
import sys
import ssl
import threading
import OpenSSL.crypto
import sqlite3 as lite

# https://pyopenssl.org/en/stable/api/crypto.html
#print(ssl.OPENSSL_VERSION)
CA_FILE = '/etc/ssl/certs/ca-certificates.crt'

dir_path = os.path.dirname(os.path.realpath(__file__))
dbfile = dir_path + '/certi.db'


def getcert(host, port):
    try:
        setdefaulttimeout(5)
        cert = ssl.get_server_certificate((host, port))
        return cert
    except ConnectionRefusedError as e:
        print("Unable to get certificate: {}".format(e))
    except ssl.SSLError as e:
        print("SSL error: {}".format(e))
        print("Your openssl version ({}) may not support any common ciphers with the target.".format(ssl.OPENSSL_VERSION))
    except:
        pass


def tostr_subject(subject):
    s = "/"
    for n, v in subject:
        s += "{}={}/".format(n.decode(), v.decode())
    return s


def print_cert(cert):
    if not cert:
        return
    try:
        x = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
    except:
        print("unable to parse certificate object")
        return
    print("                 Subject: {}".format(tostr_subject(x.get_subject().get_components())))
    print("                  Issuer: {}".format(tostr_subject(x.get_issuer().get_components())))
    print("           Serial Number: {}".format(x.get_serial_number()))
    print("     Signature Algorithm: {}".format(x.get_signature_algorithm().decode()))
    print("         Validity period: {}  {}".format(x.get_notBefore().decode(), x.get_notAfter().decode()))
    print()
    for i in range(x.get_extension_count()-1):
        e = x.get_extension(i)
        n = e.get_short_name()
        try:
            print("{0:>24}: {1}".format(n.decode(), e.__str__()))
        except OpenSSL.crypto.Error as e:
            pass


def cert_insert(target, port, cert):
    if not cert:
        return
    try:
        s = lite.connect(dbfile, isolation_level=None)
        cur = s.cursor()
        try:
            cur.execute("CREATE TABLE IF NOT EXISTS certs(id INTEGER PRIMARY KEY AUTOINCREMENT, datestamp INT, target VARCHAR, port INT, subject VARCHAR, issuer VARCHAR, sn VARCHAR, sigalgo VARCHAR, notbefore VARCHAR, notafter VARCHAR, san TEXT, cert TEXT)")
        except lite.OperationalError as e:
            #print(e)
            pass
        try:
            x = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
            san = ''
            for i in range(x.get_extension_count()-1):
                e = x.get_extension(i)
                n = e.get_short_name().decode()
                if n == "subjectAltName":
                    san = e.__str__()
            cur.execute("INSERT INTO certs(datestamp, target, port, subject, issuer, sn, sigalgo, notbefore, notafter, san, cert) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                        (datetime.now().strftime("%s"),
                        target,
                        port,
                        tostr_subject(x.get_subject().get_components()),
                        tostr_subject(x.get_issuer().get_components()),
                        str(x.get_serial_number()),
                        x.get_signature_algorithm().decode(),
                        x.get_notBefore().decode(),
                        x.get_notAfter().decode(),
                        san,
                        cert))
        except lite.Error as e:
            print("could not insert data: {}".format(e))
    except lite.Error as e:
        print("failed to connect to {}: {}".format(dbfile, e))
        sys.exit(1)

    s.close()


def mode_host(args):
    cert = getcert(args.target, args.port)
    print_cert(cert)
    cert_insert(args.target, args.port, cert)


def mode_scan(args):
    # need to parse target value
    # split out by commas, then expand from ranges ('-'), then handle cidr blocks
    list_ports = str(args.port).split(',')
    list_targets = ipaddress.ip_network(args.target)
    for item in list_targets:
        if re.search('\.0|255$', str(item)):
            print("skipping " + str(item))
            continue
        for p in list_ports:
            print("{}:{}".format(str(item), p))
            cert = getcert(str(item), p)
            print_cert(cert)
            cert_insert(str(item), p, cert)

def worker(host, port, results):
    id = "{}:{}".format(host, port)
    print("thread for {} started".format(id))
    setdefaulttimeout(5)
    try:
        cert = ssl.get_server_certificate((str(host), str(port)))
        results[id] = cert
    except TypeError as e:
        print(e)
    except:
        pass
    print("thread for {}:{} done".format(host, port))


def mode_scan2(args):
    threads = []
    results = {}
    list_targets = ipaddress.ip_network(args.target)
    list_ports = str(args.port).split(',')
    for item in list_targets:
        if re.search('\.0|255$', str(item)):
            print("skipping " + str(item))
            continue
        for p in list_ports:
            t = threading.Thread(target=worker, args=(item, p, results))
            threads.append(t)
            t.start()

    print("waiting for all threads to finish")
    for t in threads:
        t.join()

    for k, v in results.items():
        (host,port) = k.split(':')
        print("cert found on {}:{}:".format(host, port))
        print_cert(v)
        cert_insert(host, port, v)


def mode_report(args):
    #print("connecting to {}".format(dbfile))
    try:
        s = lite.connect(dbfile)
        s.row_factory = lite.Row  # this allows calling columns by name instead of index
        cur = s.cursor()
    except lite.Error as e:
        print("failed to connect to {}: {}".format(dbfile, e))
        sys.exit(1)

    if args.id:
        # display details of individual cert
        try:
            cur.execute("select datestamp, target, port, cert from certs where id = ?", (args.id,))
            row = cur.fetchone()
            print("{}  {}:{}:".format(
                  datetime.fromtimestamp(int(row['datestamp'])).strftime("%Y-%m-%d %H:%M:%S"),
                  row['target'],
                  row['port']))
            print()
            print_cert(row['cert'])
        except lite.ProgrammingError as e:
            print("exception: {}".format(e))
    else:
        # simply list all certs in the db
        try:
            cur.execute("select * from certs")
        except:
            print("select failed")
        rows = cur.fetchall()
        for row in rows:
            print("{:4} {}  {}:{}  {} ; {}  {}".format(
                row['id'],
                datetime.fromtimestamp(int(row['datestamp'])).strftime("%Y-%m-%d %H:%M:%S"),
                row['target'],
                row['port'],
                row['subject'],
                row['notafter'],
                row['san']))


def main():
    # program modes
    modes = {'host': mode_host,
             'scan': mode_scan2,
             'report': mode_report}

    parser = argparse.ArgumentParser(description='Catalog x509 certificates.')

    # positional argument
    parser.add_argument('mode',
                        action='store',
                        choices=['host', 'scan', 'file', 'dir', 'sniff', 'report'],
                        help='operating mode')
    parser.add_argument('target',
                        action='store',
                        default='',
                        nargs='?',
                        help='target of operating mode; host or network or file etc.')
    # optional arguments
    #parser.add_argument('-t', action='store', dest='target', default='localhost', help='host to test')
    parser.add_argument('-p', action='store', dest='port', default=443, help='port to test')
    parser.add_argument('-f', action='store', dest='db', default='certi.db', help='certificate db')
    parser.add_argument('-i', action='store', dest='id', default=0, help='certificate id')

    args = parser.parse_args()

    if args.mode == "host" and args.target == "":
        print("target not specified.")
        sys.exit(1)

    try:
        modes[args.mode](args)
    except:
        #print("Invalid command line arguments.")
        raise
        sys.exit()


if __name__ == "__main__":
    main()


