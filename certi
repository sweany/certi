#!/usr/bin/env python3

import argparse
from datetime import datetime
import ipaddress
import json
import os
import re
from socket import inet_aton, gethostbyaddr, gethostbyname, gethostname, setdefaulttimeout
import sys
import ssl
from concurrent.futures import ThreadPoolExecutor
from concurrent.futures import as_completed
import OpenSSL.crypto
import sqlite3 as lite

# https://pyopenssl.org/en/stable/api/crypto.html

CA_FILE = '/etc/ssl/certs/ca-certificates.crt'

dir_path = os.path.dirname(os.path.realpath(__file__))
dbfile = dir_path + '/certi.db'


class tcolor:
    red = '\033[0;31m'
    bred = '\033[1;31m'
    green = '\033[0;32m'
    bgreen = '\033[1;32m'
    yellow = '\033[0;33m'
    byellow = '\033[1;33m'
    purple = '\033[0;35m'
    bpurple = '\033[1;35m'
    orange = '\033[48;2;255;165;0m'
    reset = '\033[0m'


def getcert(host, port):
    try:
        setdefaulttimeout(10)
        cert = ssl.get_server_certificate((host, port))
        return cert
    except ConnectionRefusedError as e:
        print("Unable to get certificate: {}".format(e))
    except ssl.SSLError as e:
        print("SSL error: {}".format(e))
        print("Your openssl version ({}) may not support any common ciphers with the target.".format(ssl.OPENSSL_VERSION))
    except:
        pass


def tostr_subject(subject):
    s = "/"
    for n, v in subject:
        s += "{}={}/".format(n.decode(), v.decode())
    return s


def db_create():
    try:
        s = lite.connect(dbfile, isolation_level=None)
        cur = s.cursor()
        cur.execute("CREATE TABLE IF NOT EXISTS certs(id INTEGER PRIMARY KEY AUTOINCREMENT, datestamp INT, target VARCHAR, port INT, ptr VARCHAR, file VARCHAR, subject VARCHAR, issuer VARCHAR, sn VARCHAR, bits INT, sigalgo VARCHAR, notbefore VARCHAR, notafter VARCHAR, san TEXT, cert TEXT)")
        #cur.execute("CREATE UNIQUE INDEX idx_cert ON certs(cert)") # forcing this to be unique means you can't see the same cert being used on multiple IPs. Find another way.
    except lite.OperationalError as e:
        #print(e)
        pass


def cert_print(cert):
    if not cert:
        return
    try:
        x = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
    except:
        print("unable to parse certificate object")
        return
    validity = 'valid'
    if x.has_expired() == True:
        if sys.stdout.isatty():
            validity = tcolor.red + 'EXPIRED' + tcolor.reset
        else:
            validity = 'EXPIRED'

    print("                 Subject: {}".format(tostr_subject(x.get_subject().get_components())))
    print("                  Issuer: {}".format(tostr_subject(x.get_issuer().get_components())))
    print("           Serial Number: {}".format(x.get_serial_number()))
    print("                Key Size: {}".format(x.get_pubkey().bits()))
    print("     Signature Algorithm: {}".format(x.get_signature_algorithm().decode()))
    print("         Validity period: {}  {}  {}".format(x.get_notBefore().decode(), x.get_notAfter().decode(), validity))
    print()
    for i in range(x.get_extension_count()-1):
        e = x.get_extension(i)
        n = e.get_short_name()
        try:
            print("{0:>24}: {1}".format(n.decode(), e.__str__()))
        except OpenSSL.crypto.Error as e:
            pass
    print()


def cert_insert(target, cert, port='', ptr='', file=''):
    if not cert:
        return
    try:
        s = lite.connect(dbfile, isolation_level=None)
        cur = s.cursor()
        try:
            x = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
            san = ''
            for i in range(x.get_extension_count()-1):
                e = x.get_extension(i)
                n = e.get_short_name().decode()
                if n == "subjectAltName":
                    san = e.__str__()
            cur.execute("INSERT INTO certs(datestamp, target, port, ptr, file, subject, issuer, sn, bits, sigalgo, notbefore, notafter, san, cert) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                        (datetime.now().strftime("%s"),
                        target,
                        port,
                        ptr,
                        file,
                        tostr_subject(x.get_subject().get_components()),
                        tostr_subject(x.get_issuer().get_components()),
                        str(x.get_serial_number()),
                        x.get_pubkey().bits(),
                        x.get_signature_algorithm().decode(),
                        x.get_notBefore().decode(),
                        x.get_notAfter().decode(),
                        san,
                        cert))
        except lite.Error as e:
            print("could not insert data: {}".format(e))
    except lite.Error as e:
        print("failed to connect to {}: {}".format(dbfile, e))
        sys.exit(1)

    s.close()


def mode_host(args):
    cert = getcert(args.target, args.port)
    cert_print(cert)
    cert_insert(args.target, cert, port=args.port)


def mode_scan_worker(host, port, results):
    answer = ''
    id = "{}:{}".format(host, port)
    #print("thread for {} started".format(id))
    setdefaulttimeout(10)
    if inet_aton(str(host)):
        try:
            (answer, alias, addr) = gethostbyaddr(str(host))
            print(answer)
        except:
            #print ("unable to resolve {}".format(host))
            pass
    try:
        cert = ssl.get_server_certificate((str(host), str(port)))
        results[id] = {}
        results[id]['ptr'] = answer
        results[id]['cert'] = cert
    except TypeError as e:
        print(e)
    except:
        pass
    #print("thread for {}:{} done".format(host, port))


def mode_scan(args):
    results = {}
    list_targets = []
    for t in str(args.target).split(','):
        print(t)
        try:
            list_targets.extend(ipaddress.ip_network(t))
        except BaseException as e:
            print("exception: {}".format(e))
    list_ports = str(args.port).split(',')
    target_count = len(list_targets) * len(list_ports)
    executor = ThreadPoolExecutor(max_workers=256)
    time_start = datetime.now()
    for item in list_targets:
        for p in list_ports:
            executor.submit(mode_scan_worker, item, p, results)

    print("waiting for all threads to finish")
    executor.shutdown(wait=True)
    try:
        for f in as_completed(executor):
            print(f.result())
    except BaseException as e:
        print(e)

    time_stop = datetime.now()
    elapsed = time_stop - time_start

    for k, v in results.items():
        (host, port) = k.split(':')
        print("cert found on {}:{}:".format(host, port))
        cert_print(v['cert'])
        cert_insert(host, v['cert'], port=port, ptr=v['ptr'])
    print("{} certificates found in {} seconds.".format(len(results.items()), elapsed.seconds))
    print()


def mode_file(args):
    print("File {}:{}:".format(gethostname(), args.target))
    certs = parse_file(args.target)
    for cert in certs:
        cert_print(cert)
        cert_insert(gethostname(), cert, file=args.target)


def parse_file(file):
    list_certs = []
    try:
        with open(file, 'r') as source:
            cert = ""
            for line in source.readlines():
                if '-----BEGIN CERTIFICATE-----' in line:
                    cert = line
                elif '-----END CERTIFICATE-----' in line:
                    cert += line
                    list_certs.append(cert)
                    print(cert)
                    cert = ''
                else:
                    cert += line
    except IOError as e:
        print("unable to open {}: {}".format(file, e))
    except BaseException as e:
        print("unknown error: {}".format(e))

    return list_certs


def mode_directory(args):
    print("Directory {}".format(args.target))
    count = parse_directory(args.target)
    print("{} certificates found.".format(count))


def parse_directory(dir):
    count = 0
    for item in os.listdir(dir):
        file = dir + '/' + item
        print(file)
        if os.path.isdir(file):
            count += parse_directory(file)
        elif os.path.isfile(file):
            print("reading {}".format(file))
            certs = parse_file(file)
            for cert in certs:
                cert_print(cert)
                count += 1
                cert_insert(gethostname(), cert, file=file)
    return count


def mode_delete(args):
    try:
        s = lite.connect(dbfile)
        s.row_factory = lite.Row  # this allows calling columns by name instead of index
        cur = s.cursor()
    except lite.Error as e:
        print("failed to connect to {}: {}".format(dbfile, e))
        sys.exit(1)

    if args.id:
        try:
            cur.execute("delete from certs where id = ?", (args.id,))
            s.commit()
            print("deleted record {}".format(args.id))
        except lite.ProgrammingError as e:
            print("exception: {}".format(e))

    s.close()


def mode_list(args):
    try:
        s = lite.connect(dbfile)
        s.row_factory = lite.Row  # this allows calling columns by name instead of index
        cur = s.cursor()
    except lite.Error as e:
        print("failed to connect to {}: {}".format(dbfile, e))
        sys.exit(1)

    if args.target:
        try:
            cur.execute('select * from certs where target like ? or file like ? or subject like ? or issuer like ? or sn like ? or sigalgo like ? or bits like ? or notbefore like ? or notafter like ? or san like ?',
                       ('%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%'))
        except lite.Error as e:
            print("failed to select from db: {}".format(e))
    elif args.id:
        # display details of individual cert
        try:
            cur.execute("select datestamp, target, port, ptr, file, cert from certs where id = ?", (args.id,))
            row = cur.fetchone()
            print("{}  {}:{} ({}{}):".format(
                  datetime.fromtimestamp(int(row['datestamp'])).strftime("%Y-%m-%d %H:%M:%S"),
                  row['target'],
                  row['port'],
                  row['ptr'],
                  row['file']))
            print()
            cert_print(row['cert'])
            sys.exit(0)
        except lite.ProgrammingError as e:
            print("exception: {}".format(e))
    else:
        try:
            cur.execute("select * from certs")
        except lite.Error as e:
            print("failed to select from db: {}".format(e))

    rows = cur.fetchall()
    for row in rows:
        try:
            x = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, row['cert'])
        except:
            print("unable to parse certificate object")
            continue
        validity = 'valid'
        if x.has_expired() == True:
            if sys.stdout.isatty():
                validity = tcolor.red + 'EXPIRED' + tcolor.reset
            else:
                validity = 'EXPIRED'

        output = "{:4} {}  {}:{} ({}{})\n\t{} bit  {}  {} => {}  {}\n\tSubject: {}\n\tIssuer: {}\n\tsubjectAltName: {}\n".format(
            row['id'],
            datetime.fromtimestamp(int(row['datestamp'])).strftime("%Y-%m-%d %H:%M:%S"),
            row['target'],
            row['port'],
            row['ptr'],
            row['file'],
            row['bits'],
            row['sigalgo'],
            row['notbefore'],
            row['notafter'],
            validity,
            row['subject'],
            row['issuer'],
            row['san'])
        if sys.stdout.isatty():
            # highlight the term being searched for
            output = output.replace(args.target, tcolor.green+args.target+tcolor.reset)
        print(output)
    print()
    print("{} certificates listed.".format(len(rows)))
    print()
    s.close()


def mode_stats(args):
    try:
        s = lite.connect(dbfile)
        s.row_factory = lite.Row  # this allows calling columns by name instead of index
        cur = s.cursor()
    except lite.Error as e:
        print("failed to connect to {}: {}".format(dbfile, e))
        sys.exit(1)

    stats = {}
    stats['keysize'] = {}
    stats['sigs'] = {}
    stats['issuers'] = {}
    stats['remaining'] = {}
    stats['ports'] = {}
    stats['expiremonth'] = {}
    stats['words'] = {}
    cur.execute("select subject, port, bits, sigalgo, issuer, notafter from certs")
    rows = cur.fetchall()
    for row in rows:
        bits = str(row['bits'])
        sigalgo = str(row['sigalgo'])
        issuer = str(row['issuer'])
        notafter = str(row['notafter'])
        sections = row['subject'].split('/')
        words = []
        for s in sections:
            s = re.sub('^[A-Z]+=', '', s)
            w = s.split(' ')
            words.extend(w)
        for w in words:
            if w == '':
                continue
            try:
                stats['words'][w] += 1
            except:
                stats['words'][w] = 1

        remaining = datetime.strptime(notafter, "%Y%m%d%H%M%SZ") - datetime.now()
        days = 0
        expiremonth = notafter[:4] + '-' + notafter[4:6]
        #print(row['bits'], row['sigalgo'])
        if remaining.days < 0:
            days = 'expired'
        elif remaining.days < 31:
            days = '0-30'
        elif remaining.days < 61:
            days = '31-60'
        elif remaining.days < 91:
            days = '61-90'
        else:
            days = '90+'

        try:
            stats['keysize'][bits] += 1
        except:
            stats['keysize'][bits] = 1
        try:
            stats['sigs'][sigalgo] += 1
        except:
            stats['sigs'][sigalgo] = 1
        try:
            stats['issuers'][issuer] += 1
        except:
            stats['issuers'][issuer] = 1
        try:
            stats['remaining'][days] += 1
        except:
            stats['remaining'][days] = 1
        try:
            stats['ports'][row['port']] += 1
        except:
            stats['ports'][row['port']] = 1
        try:
            stats['expiremonth'][expiremonth] += 1
        except:
            stats['expiremonth'][expiremonth] = 1

    print("{} certificates".format(len(rows)))
    print()

    # keysize stats
    print("===== Key Sizes")
    s = sorted(stats['keysize'], key=stats['keysize'].__getitem__, reverse=True)
    for k in s:
        print("{:5}  {}".format(stats['keysize'][k], k))
    print()

    # Signature algorithm stats
    print("===== Signature Algorithms")
    s = sorted(stats['sigs'], key=stats['sigs'].__getitem__, reverse=True)
    for k in s:
        print("{:5}  {}".format(stats['sigs'][k], k))
    print()

    # Issuer stats
    print("===== Issuers")
    s = sorted(stats['issuers'], key=stats['issuers'].__getitem__, reverse=True)
    for k in s:
        print("{:5}  {}".format(stats['issuers'][k], k))
    print()

    # time to expiration <30 days, 31-60, 61-90, 91+
    print("===== Days until expiration")
    s = sorted(stats['remaining'], key=stats['remaining'].__getitem__, reverse=True)
    for k in s:
        print("{:5}  {}".format(stats['remaining'][k], k))
    print()

    # expiration month (YYYY-MM)
    print("===== Month of expiration")
    s = sorted(stats['expiremonth'])
    for k in s:
        print("{:5}  {}".format(stats['expiremonth'][k], k))
    print()

    # ports
    print("===== Ports")
    s = sorted(stats['ports'], key=stats['ports'].__getitem__, reverse=True)
    for k in s:
        print("{:5}  {}".format(stats['ports'][k], k))
    print()

    # words
    print("===== Subject words")
    s = sorted(stats['words'], key=stats['words'].__getitem__, reverse=True)
    for k in s:
        print("{:5}  {}".format(stats['words'][k], k))
    print()
    s.close()


def main():
    # program modes
    modes = {'host': mode_host,
             'scan': mode_scan,
             'file': mode_file,
             'dir': mode_directory,
             'list': mode_list,
             'stats': mode_stats,
             'delete': mode_delete}

    parser = argparse.ArgumentParser(description='Catalog x509 certificates.')

    # positional arguments
    parser.add_argument('mode',
                        action='store',
                        choices=['host', 'scan', 'file', 'dir', 'sniff', 'list', 'stats', 'delete'],
                        help='operating mode')
    parser.add_argument('target',
                        action='store',
                        default='',
                        nargs='?',
                        help='target of operating mode; host or network or file etc.')
    # optional arguments
    parser.add_argument('-p', action='store', dest='port', default=443, help='port to test')
    parser.add_argument('-f', action='store', dest='db', default='certi.db', help='certificate db')
    parser.add_argument('-i', action='store', dest='id', default=0, help='certificate id')

    args = parser.parse_args()

    if args.mode == "host" and args.target == "":
        print("target not specified.")
        sys.exit(1)

    try:
        db_create()
        modes[args.mode](args)
    except:
        sys.exit()


if __name__ == "__main__":
    main()


