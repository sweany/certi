#!/usr/bin/env python3

import argparse
from datetime import datetime
import ipaddress
import json
import os
import re
from socket import inet_aton, gethostbyaddr, gethostbyname, gethostname, setdefaulttimeout
import sys
import ssl
import threading
import OpenSSL.crypto
import sqlite3 as lite

# https://pyopenssl.org/en/stable/api/crypto.html

CA_FILE = '/etc/ssl/certs/ca-certificates.crt'

dir_path = os.path.dirname(os.path.realpath(__file__))
dbfile = dir_path + '/certi.db'


def getcert(host, port):
    try:
        setdefaulttimeout(5)
        cert = ssl.get_server_certificate((host, port))
        return cert
    except ConnectionRefusedError as e:
        print("Unable to get certificate: {}".format(e))
    except ssl.SSLError as e:
        print("SSL error: {}".format(e))
        print("Your openssl version ({}) may not support any common ciphers with the target.".format(ssl.OPENSSL_VERSION))
    except:
        pass


def tostr_subject(subject):
    s = "/"
    for n, v in subject:
        s += "{}={}/".format(n.decode(), v.decode())
    return s


def print_cert(cert):
    if not cert:
        return
    try:
        x = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
    except:
        print("unable to parse certificate object")
        return

    print("                 Subject: {}".format(tostr_subject(x.get_subject().get_components())))
    print("                  Issuer: {}".format(tostr_subject(x.get_issuer().get_components())))
    print("           Serial Number: {}".format(x.get_serial_number()))
    print("                Key Size: {}".format(x.get_pubkey().bits()))
    print("     Signature Algorithm: {}".format(x.get_signature_algorithm().decode()))
    print("         Validity period: {}  {}".format(x.get_notBefore().decode(), x.get_notAfter().decode()))
    print()
    for i in range(x.get_extension_count()-1):
        e = x.get_extension(i)
        n = e.get_short_name()
        try:
            print("{0:>24}: {1}".format(n.decode(), e.__str__()))
        except OpenSSL.crypto.Error as e:
            pass


def cert_insert(target, port, cert):
    if not cert:
        return
    try:
        s = lite.connect(dbfile, isolation_level=None)
        cur = s.cursor()
        try:
            cur.execute("CREATE TABLE IF NOT EXISTS certs(id INTEGER PRIMARY KEY AUTOINCREMENT, datestamp INT, target VARCHAR, port INT, subject VARCHAR, issuer VARCHAR, sn VARCHAR, bits INT, sigalgo VARCHAR, notbefore VARCHAR, notafter VARCHAR, san TEXT, cert TEXT)")
        except lite.OperationalError as e:
            #print(e)
            pass
        try:
            x = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
            san = ''
            for i in range(x.get_extension_count()-1):
                e = x.get_extension(i)
                n = e.get_short_name().decode()
                if n == "subjectAltName":
                    san = e.__str__()
            cur.execute("INSERT INTO certs(datestamp, target, port, subject, issuer, sn, bits, sigalgo, notbefore, notafter, san, cert) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                        (datetime.now().strftime("%s"),
                        target,
                        port,
                        tostr_subject(x.get_subject().get_components()),
                        tostr_subject(x.get_issuer().get_components()),
                        str(x.get_serial_number()),
                        x.get_pubkey().bits(),
                        x.get_signature_algorithm().decode(),
                        x.get_notBefore().decode(),
                        x.get_notAfter().decode(),
                        san,
                        cert))
        except lite.Error as e:
            print("could not insert data: {}".format(e))
    except lite.Error as e:
        print("failed to connect to {}: {}".format(dbfile, e))
        sys.exit(1)

    s.close()


def mode_host(args):
    cert = getcert(args.target, args.port)
    print_cert(cert)
    cert_insert(args.target, args.port, cert)


def mode_scan_worker(host, port, results):
    id = "{}:{}".format(host, port)
    #print("thread for {} started".format(id))
    setdefaulttimeout(5)
    if inet_aton(str(host)):
        try:
            answer = gethostbyaddr(str(host))
            print(answer)
        except:
            #print ("unable to resolve {}".format(host))
            pass
    try:
        cert = ssl.get_server_certificate((str(host), str(port)))
        results[id] = cert
    except TypeError as e:
        print(e)
    except:
        pass
    #print("thread for {}:{} done".format(host, port))


def mode_scan(args):
    threads = []
    results = {}
    list_targets = ipaddress.ip_network(args.target)
    list_ports = str(args.port).split(',')
    for item in list_targets:
        if re.search('\.0|255$', str(item)):
            print("skipping " + str(item))
            continue
        for p in list_ports:
            t = threading.Thread(target=mode_scan_worker, args=(item, p, results))
            threads.append(t)
            t.start()

    print("waiting for all threads to finish")
    for t in threads:
        t.join()

    for k, v in results.items():
        (host, port) = k.split(':')
        print("cert found on {}:{}:".format(host, port))
        print_cert(v)
        cert_insert(host, port, v)


def mode_file(args):
    print("File {}:{}:".format(gethostname(), args.target))
    certs = parse_file(args.target)
    for cert in certs:
        print_cert(cert)
        cert_insert(gethostname(), args.target, cert)


def parse_file(file):
    list_certs = []
    try:
        with open(file, 'r') as source:
            cert = ""
            for line in source.readlines():
                if '-----BEGIN CERTIFICATE-----' in line:
                    cert = line
                elif '-----END CERTIFICATE-----' in line:
                    cert += line
                    list_certs.append(cert)
                    print(cert)
                    cert = ''
                else:
                    cert += line
    except IOError as e:
        print("unable to open {}: {}".format(file, e))

    return list_certs


def mode_delete(args):
    try:
        s = lite.connect(dbfile)
        s.row_factory = lite.Row  # this allows calling columns by name instead of index
        cur = s.cursor()
    except lite.Error as e:
        print("failed to connect to {}: {}".format(dbfile, e))
        sys.exit(1)

    if args.id:
        try:
            cur.execute("delete from certs where id = ?", (args.id,))
            s.commit()
            print("deleted record {}".format(args.id))
        except lite.ProgrammingError as e:
            print("exception: {}".format(e))

    s.close()


def mode_list(args):
    try:
        s = lite.connect(dbfile)
        s.row_factory = lite.Row  # this allows calling columns by name instead of index
        cur = s.cursor()
    except lite.Error as e:
        print("failed to connect to {}: {}".format(dbfile, e))
        sys.exit(1)

    if args.target:
        try:
            cur.execute('select * from certs where target like ? or subject like ? or issuer like ? or sn like ? or sigalgo like ? or bits like ? or notbefore like ? or notafter like ? or san like ?',
                ('%'+args.target+'%','%'+args.target+'%','%'+args.target+'%','%'+args.target+'%','%'+args.target+'%','%'+args.target+'%','%'+args.target+'%','%'+args.target+'%','%'+args.target+'%'))
        except lite.Error as e:
            print("failed to select from db: {}".format(e))
    elif args.id:
        # display details of individual cert
        try:
            cur.execute("select datestamp, target, port, cert from certs where id = ?", (args.id,))
            row = cur.fetchone()
            print("{}  {}:{}:".format(
                  datetime.fromtimestamp(int(row['datestamp'])).strftime("%Y-%m-%d %H:%M:%S"),
                  row['target'],
                  row['port']))
            print()
            print_cert(row['cert'])
        except lite.ProgrammingError as e:
            print("exception: {}".format(e))
    else:
        try:
            cur.execute("select * from certs")
        except lite.Error as e:
            print("failed to select from db: {}".format(e))

    rows = cur.fetchall()
    for row in rows:
        output = "{:4} {}  {}:{}  {} bit  {}  {} => {}\n\tSubject: {}\n\tIssuer: {}\n\tsubjectAltName: {}\n".format(
            row['id'],
            datetime.fromtimestamp(int(row['datestamp'])).strftime("%Y-%m-%d %H:%M:%S"),
            row['target'],
            row['port'],
            row['bits'],
            row['sigalgo'],
            row['notbefore'],
            row['notafter'],
            row['subject'],
            row['issuer'],
            row['san'])
        if sys.stdout.isatty():
            # highlight the term being searched for
            output = output.replace(args.target, '\033[31m'+args.target+'\033[0m')
        print(output)

    s.close()


def mode_stats(args):
    try:
        s = lite.connect(dbfile)
        s.row_factory = lite.Row  # this allows calling columns by name instead of index
        cur = s.cursor()
    except lite.Error as e:
        print("failed to connect to {}: {}".format(dbfile, e))
        sys.exit(1)

    keys = {}
    sigs = {}
    issuers = {}
    cur.execute("select bits, sigalgo, issuer from certs")
    rows = cur.fetchall()
    for row in rows:
        bits = str(row['bits'])
        sigalgo = str(row['sigalgo'])
        issuer = str(row['issuer'])
        #print(row['bits'], row['sigalgo'])
        try:
            keys[bits] += 1
        except:
            keys[bits] = 1
        try:
            sigs[sigalgo] += 1
        except:
            sigs[sigalgo] = 1
        try:
            issuers[issuer] += 1
        except:
            issuers[issuer] = 1

    # keysize stats
    print("===== Key Sizes")
    skeys = sorted(keys, key=keys.__getitem__, reverse=True)
    for k in skeys:
        print("{:5}  {}".format(keys[k], k))
    print()

    # Signature algorithm stats
    print("===== Signature Algorithms")
    ssigs = sorted(sigs, key=sigs.__getitem__, reverse=True)
    for k in ssigs:
        print("{:5}  {}".format(sigs[k], k))
    print()

    # Issuer stats
    print("===== Issuers")
    sissuers = sorted(issuers, key=issuers.__getitem__, reverse=True)
    for k in sissuers:
        print("{:5}  {}".format(issuers[k], k))
    print()

    s.close()


def main():
    # program modes
    modes = {'host': mode_host,
             'scan': mode_scan,
             'file': mode_file,
             'list': mode_list,
             'stats': mode_stats,
             'delete': mode_delete}

    parser = argparse.ArgumentParser(description='Catalog x509 certificates.')

    # positional arguments
    parser.add_argument('mode',
                        action='store',
                        choices=['host', 'scan', 'file', 'dir', 'sniff', 'list', 'stats', 'delete'],
                        help='operating mode')
    parser.add_argument('target',
                        action='store',
                        default='',
                        nargs='?',
                        help='target of operating mode; host or network or file etc.')
    # optional arguments
    parser.add_argument('-p', action='store', dest='port', default=443, help='port to test')
    parser.add_argument('-f', action='store', dest='db', default='certi.db', help='certificate db')
    parser.add_argument('-i', action='store', dest='id', default=0, help='certificate id')

    args = parser.parse_args()

    if args.mode == "host" and args.target == "":
        print("target not specified.")
        sys.exit(1)

    try:
        modes[args.mode](args)
    except:
        sys.exit()


if __name__ == "__main__":
    main()


