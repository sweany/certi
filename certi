#!/usr/bin/env python3

import argparse
from datetime import datetime
import ipaddress
import json
import os
import re
from socket import inet_aton, gethostbyaddr, gethostbyname, gethostname, setdefaulttimeout
import sys
import ssl
from concurrent.futures import ThreadPoolExecutor
from concurrent.futures import as_completed
import OpenSSL.crypto
import sqlite3 as lite

# https://pyopenssl.org/en/stable/api/crypto.html

CA_FILE = '/etc/ssl/certs/ca-certificates.crt'


class tcolor:
    red = '\033[0;31m'
    bred = '\033[1;31m'
    green = '\033[0;32m'
    bgreen = '\033[1;32m'
    yellow = '\033[0;33m'
    byellow = '\033[1;33m'
    purple = '\033[0;35m'
    bpurple = '\033[1;35m'
    orange = '\033[48;2;255;165;0m'
    reset = '\033[0m'


def getcert(host, port):
    try:
        setdefaulttimeout(10)
        cert = ssl.get_server_certificate((host, port))
        return cert
    except ConnectionRefusedError as e:
        print("Unable to get certificate: {}".format(e))
    except ssl.SSLError as e:
        print("SSL error: {}".format(e))
        print("Your openssl version ({}) may not support any common ciphers with the target.".format(ssl.OPENSSL_VERSION))
    except:
        pass


def tostr_subject(subject):
    s = "/"
    for n, v in subject:
        s += "{}={}/".format(n.decode(), v.decode())
    return s


def db_create(dbfile):
    try:
        s = lite.connect(dbfile, isolation_level=None)
        cur = s.cursor()
        cur.execute("CREATE TABLE IF NOT EXISTS certs(id INTEGER PRIMARY KEY AUTOINCREMENT, datestamp INT, target VARCHAR, port INT, ptr VARCHAR, file VARCHAR, subject VARCHAR, issuer VARCHAR, sn VARCHAR, bits INT, sigalgo VARCHAR, notbefore VARCHAR, notafter VARCHAR, san TEXT, cert TEXT)")
        #cur.execute("CREATE UNIQUE INDEX idx_cert ON certs(cert)") # forcing this to be unique means you can't see the same cert being used on multiple IPs. Find another way.
    except lite.OperationalError as e:
        print(e)
        pass


def cert_print(cert):
    # Raise exceptions instead of ambiguous return statement.
    if not cert:
        raise TypeError("Valid certificate is needed as a parameter for cert_print()")
    try:
        x = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
    except Exception as e:
        raise ValueError("Unable to parse certificate object")

    has_basicConstraints = False
    validity = 'valid'
    warning_bits = ''
    warning_sig = ''
    if int(x.get_pubkey().bits()) < 2048:
        if sys.stdout.isatty():
            warning_bits = tcolor.red + 'WEAK' + tcolor.reset
        else:
            warning_bits = 'WEAK'

    if x.get_signature_algorithm().decode() == 'md5WithRSAEncryption':
        if sys.stdout.isatty():
            warning_sig = tcolor.red + 'WEAK' + tcolor.reset
        else:
            warning_sig = 'WEAK'
    if x.get_signature_algorithm().decode() == 'sha1WithRSAEncryption':
        if sys.stdout.isatty():
            warning_sig = tcolor.red + 'WEAK' + tcolor.reset
        else:
            warning_sig = 'WEAK'

    # When returning a boolean, this way is 'more pythonic'
    if x.has_expired():
        if sys.stdout.isatty():
            validity = tcolor.red + 'EXPIRED' + tcolor.reset
        else:
            validity = 'EXPIRED'
    for i in range(x.get_extension_count()-1):
        e = x.get_extension(i)
        n = e.get_short_name().decode()
        if (n == 'basicConstraints'):
            has_basicConstraints = True

    print("                 Subject: {}".format(tostr_subject(x.get_subject().get_components())))
    print("                  Issuer: {}".format(tostr_subject(x.get_issuer().get_components())))
    print("           Serial Number: {}".format(x.get_serial_number()))
    print("                Key Size: {}  {}".format(x.get_pubkey().bits(), warning_bits))
    print("     Signature Algorithm: {}  {}".format(x.get_signature_algorithm().decode(), warning_sig))
    print("         Validity period: {}  {}  {}".format(x.get_notBefore().decode(), x.get_notAfter().decode(), validity))
    print("           SHA256 Digest: {}".format(x.digest('sha256').decode()))
    print("             SHA1 Digest: {}".format(x.digest('sha1').decode()))
    print()
    if has_basicConstraints is False:
        if sys.stdout.isatty():
            print("\t" + tcolor.red + 'No basicConstraints extension' + tcolor.reset)
        else:
            print("\tNo basicConstraints extension")
        print()
    for i in range(x.get_extension_count()-1):
        e = x.get_extension(i)
        n = e.get_short_name()
        try:
            print("{0:>24}: {1}".format(n.decode(), e.__str__()))
        except OpenSSL.crypto.Error as e:
            pass
    print()


def cert_insert(dbfile, target, cert, port='', ptr='', file=''):
    if not cert:
        return
    try:
        s = lite.connect(dbfile, isolation_level=None)
        cur = s.cursor()
        try:
            x = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
            san = ''
            for i in range(x.get_extension_count()-1):
                e = x.get_extension(i)
                n = e.get_short_name().decode()
                if n == "subjectAltName":
                    san = e.__str__()
            cur.execute("INSERT INTO certs(datestamp, target, port, ptr, file, subject, issuer, sn, bits, sigalgo, notbefore, notafter, san, cert) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                        (datetime.now().strftime("%s"),
                        target,
                        port,
                        ptr,
                        file,
                        tostr_subject(x.get_subject().get_components()),
                        tostr_subject(x.get_issuer().get_components()),
                        str(x.get_serial_number()),
                        x.get_pubkey().bits(),
                        x.get_signature_algorithm().decode(),
                        x.get_notBefore().decode(),
                        x.get_notAfter().decode(),
                        san,
                        cert))
        except lite.Error as e:
            print("could not insert data: {}".format(e))
    except lite.Error as e:
        print("failed to connect to {}: {}".format(dbfile, e))
        sys.exit(1)

    s.close()


def mode_host(args):
    cert = getcert(args.target, args.port)
    cert_print(cert)
    cert_insert(args.db, args.target, cert, port=args.port)


def mode_scan_worker(host, port, results):
    answer = ''
    id = "{}:{}".format(host, port)
    #print("thread for {} started".format(id))
    setdefaulttimeout(10)
    if inet_aton(str(host)):
        try:
            (answer, alias, addr) = gethostbyaddr(str(host))
            #print(answer)
        except:
            #print ("unable to resolve {}".format(host))
            pass
    try:
        cert = ssl.get_server_certificate((str(host), str(port)))
        results[id] = {}
        results[id]['ptr'] = answer
        results[id]['cert'] = cert
    except TypeError as e:
        print(e)
    except:
        pass
    #print("thread for {}:{} done".format(host, port))


def mode_scan_driver_cf(targets, ports, threadlimit):
    results = {}
    list_futures = []
    target_count = len(targets) * len(ports)
    try:
        executor = ThreadPoolExecutor(max_workers=int(threadlimit))
    except BaseException as e:
        print(e)

    for item in targets:
        for p in ports:
            try:
                list_futures.append(executor.submit(mode_scan_worker, item, p, results))
            except BaseException as e:
                print(e)

    print("waiting for all threads to finish")
    #executor.shutdown(wait=True)
    #executor.shutdown()
    i = 0
    try:
        for f in as_completed(list_futures):
            i += 1
            sys.stdout.write(" {}/{} ({:.1f}%) completed\r".format(i, target_count, (i/target_count)*100))
    except BaseException as e:
        print(e)

    return results


def mode_scan_driver_tp(targets, ports):
    from multiprocessing.pool import ThreadPool
    results = {}
    pool = ThreadPool(256)

    for item in targets:
        for p in ports:
            pool.apply_async(mode_scan_worker, args=(item, p, results))

    print("waiting for all threads to finish")
    pool.close()
    pool.join()

    return results


def mode_scan_driver_t(targets, ports):
    import threading
    threads = []
    results = {}

    for item in targets:
        for p in ports:
            t = threading.Thread(target=mode_scan_worker, args=(item, p, results))
            threads.append(t)
            t.start()

    print("waiting for all threads to finish")
    for t in threads:
        t.join()

    return results


def mode_scan(args):
    list_targets = []
    for t in str(args.target).split(','):
        print(t)
        try:
            list_targets.extend(ipaddress.ip_network(t))
        except BaseException as e:
            print("exception: {}".format(e))
    list_ports = str(args.port).split(',')
    time_start = datetime.now()

    # concurrent.futures.ThreadPoolExecutor variant
    results = mode_scan_driver_cf(list_targets, list_ports, args.limit)
    # multiprocessing.pool.ThreadPool variant
    #results = mode_scan_driver_tp(list_targets, list_ports)
    # threading variant
    #results = mode_scan_driver_t(list_targets, list_ports)
    # asyncio variant?

    time_stop = datetime.now()
    elapsed = time_stop - time_start

    for k, v in results.items():
        (host, port) = k.split(':')
        print("cert found on {}:{}:".format(host, port))
        cert_print(v['cert'])
        cert_insert(args.db, host, v['cert'], port=port, ptr=v['ptr'])
    print("{} certificates found in {} seconds.".format(len(results.items()), elapsed.seconds))
    print()


def mode_file(args):
    print("File {}:{}:".format(gethostname(), args.target))
    certs = parse_file(args.target)
    for cert in certs:
        cert_print(cert)
        cert_insert(args.db, gethostname(), cert, file=args.target)


def parse_file(file):
    list_certs = []
    try:
        with open(file, 'r') as source:
            cert = ""
            for line in source.readlines():
                if '-----BEGIN CERTIFICATE-----' in line:
                    cert = line
                elif '-----END CERTIFICATE-----' in line:
                    cert += line
                    list_certs.append(cert)
                    print(cert)
                    cert = ''
                else:
                    cert += line
    except IOError as e:
        print("unable to open {}: {}".format(file, e))
    except BaseException as e:
        print("unknown error: {}".format(e))

    return list_certs


def mode_directory(args):
    print("Directory {}".format(args.target))
    count = 0
    list_files = parse_directory(args.target)
    for f in list_files:
        print("reading {}".format(f))
        certs = parse_file(f)
        for cert in certs:
            cert_print(cert)
            count += 1
            cert_insert(args.db, gethostname(), cert, file=f)
    print("{} certificates found.".format(count))


def parse_directory(dir):
    list_files = []
    for item in os.listdir(dir):
        file = dir + '/' + item
        print(file)
        if os.path.isdir(file):
            list_files.extend(parse_directory(file))
        elif os.path.isfile(file):
            list_files.append(file)
    return list_files


def mode_delete(args):
    try:
        s = lite.connect(args.db)
        s.row_factory = lite.Row  # this allows calling columns by name instead of index
        cur = s.cursor()
    except lite.Error as e:
        print("failed to connect to {}: {}".format(args.db, e))
        sys.exit(1)

    if args.id:
        try:
            cur.execute("delete from certs where id = ?", (args.id,))
            s.commit()
            print("deleted record {}".format(args.id))
        except lite.ProgrammingError as e:
            print("exception: {}".format(e))

    s.close()


def mode_list(args):
    try:
        s = lite.connect(args.db)
        s.row_factory = lite.Row  # this allows calling columns by name instead of index
        cur = s.cursor()
    except lite.Error as e:
        print("failed to connect to {}: {}".format(args.db, e))
        sys.exit(1)

    if args.target:
        try:
            cur.execute('select * from certs where target like ? or file like ? or subject like ? or issuer like ? or sn like ? or sigalgo like ? or bits like ? or notbefore like ? or notafter like ? or san like ?',
                       ('%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%'))
        except lite.Error as e:
            print("failed to select from db: {}".format(e))
    elif args.id:
        # display details of individual cert
        try:
            cur.execute("select datestamp, target, port, ptr, file, cert from certs where id = ?", (args.id,))
        except lite.ProgrammingError as e:
            print("exception: {}".format(e))
        row = cur.fetchone()
        cert = row['cert']
        print("{}  {}:{} ({}{}):".format(
              datetime.fromtimestamp(int(row['datestamp'])).strftime("%Y-%m-%d %H:%M:%S"),
              row['target'],
              row['port'],
              row['ptr'],
              row['file']))
        print()
        cert_print(cert)
        # other targets with the same cert
        try:
            cur.execute("select target, port, ptr, file from certs where cert = ?", (cert,))
        except lite.ProgrammingError as e:
            print("exception: {}".format(e))
        rows = cur.fetchall()
        if len(rows):
            print("{} targets contain the same certificate:".format(len(rows)))
        for row in rows:
            print("  {}:{} ({}{})".format(row['target'], row['port'], row['ptr'], row['file']))
        sys.exit()

    else:
        try:
            cur.execute("select * from certs")
        except lite.Error as e:
            print("failed to select from db: {}".format(e))

    rows = cur.fetchall()
    for row in rows:
        try:
            x = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, row['cert'])
        except:
            print("unable to parse certificate object")
            continue
        validity = 'valid'
        if x.has_expired():
            if sys.stdout.isatty():
                validity = tcolor.red + 'EXPIRED' + tcolor.reset
            else:
                validity = 'EXPIRED'

        output = "{:4} {}  {}:{} ({}{})\n\t{} bit  {}  {} => {}  {}\n\tSubject: {}\n\tIssuer: {}\n\tsubjectAltName: {}\n".format(
            row['id'],
            datetime.fromtimestamp(int(row['datestamp'])).strftime("%Y-%m-%d %H:%M:%S"),
            row['target'],
            row['port'],
            row['ptr'],
            row['file'],
            row['bits'],
            row['sigalgo'],
            row['notbefore'],
            row['notafter'],
            validity,
            row['subject'],
            row['issuer'],
            row['san'])
        if sys.stdout.isatty():
            # highlight the term being searched for
            output = output.replace(args.target, tcolor.green+args.target+tcolor.reset)
        print(output)
    print()
    print("{} certificates listed.".format(len(rows)))
    print()
    s.close()


def mode_stats(args):
    try:
        s = lite.connect(args.db)
        s.row_factory = lite.Row  # this allows calling columns by name instead of index
        cur = s.cursor()
    except lite.Error as e:
        print("failed to connect to {}: {}".format(args.db, e))
        sys.exit(1)

    distinct_count = 0
    stats = {}
    stats['keysize'] = {}
    stats['sigs'] = {}
    stats['issuers'] = {}
    stats['remaining'] = {}
    stats['ports'] = {}
    stats['expiremonth'] = {}
    stats['words'] = {}
    stats['slash24'] = {}
    stats['slash16'] = {}
    stats['slash8'] = {}

    if args.target:
        try:
            cur.execute('select count(distinct cert) from certs where target like ? or file like ? or subject like ? or issuer like ? or sn like ? or sigalgo like ? or bits like ? or notbefore like ? or notafter like ? or san like ?',
                       ('%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%'))
            distinct_count = int(cur.fetchone()[0])
            cur.execute('select * from certs where target like ? or file like ? or subject like ? or issuer like ? or sn like ? or sigalgo like ? or bits like ? or notbefore like ? or notafter like ? or san like ?',
                       ('%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%', '%'+args.target+'%'))
        except lite.Error as e:
            print("failed to select from db: {}".format(e))
    else:
        try:
            cur.execute("select count(distinct cert) from certs")
            distinct_count = int(cur.fetchone()[0])
            cur.execute("select target, subject, port, bits, sigalgo, issuer, notafter from certs")
        except lite.Error as e:
            print("failed to select from db: {}".format(e))

    rows = cur.fetchall()
    for row in rows:
        bits = str(row['bits'])
        sigalgo = str(row['sigalgo'])
        issuer = str(row['issuer'])
        notafter = str(row['notafter'])
        sections = row['subject'].split('/')
        words = []
        for s in sections:
            s = re.sub('^[A-Z]+=', '', s)
            w = s.split(' ')
            words.extend(w)
        for w in words:
            if w == '':
                continue
            try:
                stats['words'][w] += 1
            except:
                stats['words'][w] = 1

        try:
            if re.match("\d+\.\d+\.\d+\.\d+", row['target']):
                octets = row['target'].split('.')
                octets[3] = '0'
                slash24 = '.'.join(octets)
                octets[2] = '0'
                slash16 = '.'.join(octets)
                octets[1] = '0'
                slash8 = '.'.join(octets)
                try:
                    stats['slash24'][slash24] += 1
                except:
                    stats['slash24'][slash24] = 1
                try:
                    stats['slash16'][slash16] += 1
                except:
                    stats['slash16'][slash16] = 1
                try:
                    stats['slash8'][slash8] += 1
                except:
                    stats['slash8'][slash8] = 1
        except BaseException as e:
            print(e)
            pass

        remaining = datetime.strptime(notafter, "%Y%m%d%H%M%SZ") - datetime.now()
        days = 0
        expiremonth = notafter[:4] + '-' + notafter[4:6]
        #print(row['bits'], row['sigalgo'])
        if remaining.days < 0:
            days = 'expired'
        elif remaining.days < 31:
            days = '0-30'
        elif remaining.days < 61:
            days = '31-60'
        elif remaining.days < 91:
            days = '61-90'
        else:
            days = '90+'

        try:
            stats['keysize'][bits] += 1
        except:
            stats['keysize'][bits] = 1
        try:
            stats['sigs'][sigalgo] += 1
        except:
            stats['sigs'][sigalgo] = 1
        try:
            stats['issuers'][issuer] += 1
        except:
            stats['issuers'][issuer] = 1
        try:
            stats['remaining'][days] += 1
        except:
            stats['remaining'][days] = 1
        try:
            stats['ports'][row['port']] += 1
        except:
            stats['ports'][row['port']] = 1
        try:
            stats['expiremonth'][expiremonth] += 1
        except:
            stats['expiremonth'][expiremonth] = 1

    print("{} certificates, {} unique".format(len(rows), distinct_count))
    print()

    print_histogram("Key Sizes", stats['keysize'], args.limit)
    print_histogram("Signature Algorithms", stats['sigs'], args.limit)
    print_histogram("Issuers", stats['issuers'], args.limit)
    print_histogram("Days until expiration", stats['remaining'], args.limit)
    print_histogram("Month of expiration", stats['expiremonth'], args.limit)
    print_histogram("Ports", stats['ports'], args.limit)
    print_histogram("Subject words", stats['words'], args.limit)
    print_histogram("/24 networks", stats['slash24'], args.limit)
    print_histogram("/16 networks", stats['slash16'], args.limit)
    print_histogram("/8 networks", stats['slash8'], args.limit)

    #s.close()


def print_histogram(title, d, limit=10):
    limit = int(limit)
    s = sorted(d, key=d.__getitem__, reverse=True)
    unique = len(s)
    print("{}  ({} unique)".format(title, unique))
    print('====================')
    for k in s[0:limit]:
        print("{:5}  {}".format(d[k], k))
    print()


def main():
    # program modes
    modes = {'host': mode_host,
             'scan': mode_scan,
             'file': mode_file,
             'dir': mode_directory,
             'list': mode_list,
             'stats': mode_stats,
             'delete': mode_delete}

    parser = argparse.ArgumentParser(description='Catalog x509 certificates.')

    # positional arguments
    parser.add_argument('mode',
                        action='store',
                        choices=['host', 'scan', 'file', 'dir', 'sniff', 'list', 'stats', 'delete'],
                        help='operating mode')
    parser.add_argument('target',
                        action='store',
                        default='',
                        nargs='?',
                        help='target of operating mode; host or network or file etc.')
    # optional arguments
    parser.add_argument('-p', action='store', dest='port', default=443, help='port to test')
    parser.add_argument('-f', action='store', dest='db', default='certi.db', help='certificate db')
    parser.add_argument('-i', action='store', dest='id', default=0, help='certificate id')
    # probably want to do this with a sub-parse so we can have different defaults for different operational modes
    parser.add_argument('-l', action='store', dest='limit', default=512, type=int, help='limit')

    args = parser.parse_args()

    if args.mode == "host" and args.target == "":
        print("target not specified.")
        sys.exit(1)

    dir_path = os.path.dirname(os.path.realpath(__file__))
    if re.match("^/", args.db):
        # user has specified a full path
        pass
    else:
        args.db = dir_path + '/' + args.db

    print("db path {}".format(args.db))
    try:
        db_create(args.db)
        modes[args.mode](args)
    except BaseException as e:
        print(e)
        sys.exit()


if __name__ == "__main__":
    main()


